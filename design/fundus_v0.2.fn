;;; つくる言語`fundus`の仕様を揉むスケッチ ver. 2
;;;
;;; fundus言語の構文の基本事項は以下:
;;;
;;; - 行末にセミコロンはない言語
;;;    - 改行文字が区切りになる
;;;    - 一部例外できるかも...`if`式とかで...
;;; - 式指向の言語 (ほぼぜんぶ式)
;;; - 行コメント: `; なんかもじれつ`
;;;     - 行末までがコメンと
;;;     - その前にはなにがあってもよい
;;; - ドキュメントコメント: `;;; もじれつ`
;;;     - 直後の要素 (モジュールなり変数なり) のdoc commentとなる
;;;     - doc commentではCommonMarkつかえる
;;;     - 1行目は特別扱いされる (short descriptionとなる)
;;; - モジュール (名前空間) の定義: `mod おなまえ {なかみ}`
;;;     - `{なかみ}`を端折ると、その行以降がそのモジュール内になる
;;;     - モジュール内に`export {なまえ1, なまえ2, ...}`を置くと中の名前が公開される
;;;         - 複数個あったらマージされる
;;;         - お作法としては「モジュール先頭に書け」
;;; - 変数の定義: `let おなまえ = あたい`
;;;     -型を書けるときの構文: `let おなまえ: かた = あたい`
;;; - 手続きの定義: `fn おなまえ (ひきすう1, ひきすう2, ...) -> かた {ほんたい...}`
;;;     - 手続きの本体部分はカーリーブラケットで囲む系
;;;     - 値は常にreturnされる
;;;     - 型を書けるときの構文: `fn おなまえ (ひきすう1, ひきすう2, ...) -> かた {ほんたい...}`
;;; - 手続きの呼び出し: `おなまえ (あたい1, あたい2, ...)`
;;;     - 区切りと範囲がわからないと書くときめんどいことがわかったので (`やめました: 手続きの呼び出し`参照)
;;; - 階層の辿り方:
;;;     - 名前空間を辿るときは`::`
;;;     - データ構造を辿るときは`.`
;;;
;;;
;;; - やめました: 手続きの呼び出し: `おなまえ あたい1 あたい2 ...`
;;;     - 引数の区切りは空白文字
;;;     - デフォルトの手続き呼び出しは左結合的
;;;         - 例`: `aaa bbb ccc ddd` -> `aaa(bbb(ccc(ddd)))`
;;;     - なので引数のとこに手続き呼び出しを書きたかったらカッコで囲む
;;;         - 例`: `aaa (bbb ccc) ddd` -> `aaa(bbb(ccc)(ddd))`
;;     - カッコ地獄が嫌なときはHaskellみたいに関数適用だけど右結合の演算子を入れるのもアリ
;;;         - 例 (デフォルト): `print (sum (map (+10)) (filter odd [1..10]))`
;;;         - 例 (カッコ節約): `print $ sum $ map (+10) $ filter odd [1..10]`
;;;         - [なんか魔境っぽいからやめこかな...](https://stackoverflow.com/questions/940382/what-is-the-difference-between-dot-and-dollar-sign)
;;;         - [やっぱり魔境だからやめよ...](https://qiita.com/TTsurutani/items/201200c1f288b0d03e78)
;;;
;;; ↓と、いうわけでモジュール定義です。この行以降かつ次のmodがくるまでは`FundusSketch`モジュールの中。
mod FundusSketch

;;;; モジュールメンバーの公開
;;;;

; モジュールが公開する名前
; ちなみに変数と手続きはは名前空間が別。いわゆるLisp-2。
export {
  show_greeting,
}

;;;; モジュールのインポート
;;;;

; ちなみにここでのモジュールの構造は以下
; stdlib {
;   string {
;     fn format,
;   }
;   time {
;     fn current_time,
;   }
; }

; モジュールをリネームしてインポート
; リネームしないなら名前そのままインポート
use stdlib::string as str

; モジュール内のメンバーをリネームしてインポート
use time::{current_time as time_now}

;;;; 変数定義
;;;;

; 書式化文字列はRustみたいに`{}`が値を入れるところとする
; 中にいろいろ書くと書式指定みたいなかんじ
let greeting_format = "hello, {}!"

;;;; 手続き定義とか呼び出しとか
;;;;

; `msg`は型ではない。名前。しかもどこにも使われない
; 返り値の存在を示しているだけ
fn format_greeting (name) -> msg {
  ; こいつは文字列を返す手続きです
  str::format!(greeting_format, name)
}

fn show_greeting (name) {
  ; `if`は式なのでそれ自体が値をかえす
  ; 型を入れるときには真と偽の節両方の型が一致しないと型エラーとなる
  let greeting = if name == "" {
    "名を名乗れ"
  } else if name == "mario" {
    "ｲﾔｯｯﾌｩｩｩｩｩｩ!!!!"
  } else if name == "fundhosi" {
    "？？？？？？"
  } else {
    format_greeting(name)
  }

  ; こんな感じでフル修飾すればインポートなしでも呼べる
  stdlib::io::print (greeting)

  ; 同名の変数はシャドウされる (Rustといっしょ)
  let now = time_now()  ; ここでnowが10:00:00.000になる
  let now = time_now()  ; ここでnowが10:00:00.001とかになる。前のnowは後ろではもう見えない

  ; 変数のシャドウイングは変形するとだいたい以下みたいな感じ:
  ;
  ; let now = time_now()  ; ここでnowが10:00:00.000になる
  ;
  ; {                       ; このスコープ内で定義された名前はここのみで有効
  ;   let now = time_now()  ; ここでnowが10:00:00.001とかになる。前のnowは後ろではもう見えない
  ;
  ;   ; <- ここに2個めのlet以降のコードがくる
  ; }

  stdlib::io::print (str::format ("ただいまの時刻は{time,HH:MM}です！", now))
}

; 特別なモジュール: `main`
; `main`モジュールはスクリプトのトップレベル
; エントリポイントは`main`手続き
;
; ファイル先頭にmodを書かなければそこはmainモジュール
; もしmainモジュールがない場合はスクリプトが実行されない
; なので問題はたいていおこならに
; (ここでは上に別のモジュールがあるのでmodを宣言してる)
mod main

fn main {
  show_greeting ("mashiro")
}
